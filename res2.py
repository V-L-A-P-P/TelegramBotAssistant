import telebotimport osimport timeimport threadingimport MyFileWorkerimport loggingimport tracebackimport PhrasesGeneratorimport jsonimport DataWithBackupDumperimport ToOperatorByEmailSenderimport ToOperatorByTelegramSenderfrom datetime import datetimefrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email import encodersfrom abc import ABC, abstractmethodlogging.basicConfig(    format='%(asctime)s: %(message)s',    level=logging.INFO,    filename='sample.log')# TOKEN = "2067410069:AAFKW4DZBnfBe0TgjJj0XVZgtTpAv99GQ-o"# TOKEN = "2099803367:AAGUn8M-X9_ivu2a3i76irQOGt5ryKkQpEs" not for use# TOKEN = "2054566773:AAE2sa4UmBWR8L8IbdT3CgTZo9v1NIzgVGg"# test for hope# TOKEN = "2034775644:AAHxVkYH1L8F6WPcErp0e7iNT82TYxAlNdM"  # test for meTOKEN = "5004761639:AAF6eincMdb2JSgKtw7-aZJRyYwaEpgYAmg"NEXT_REMINDER = 720DATA_ITEMS = MyFileWorker.load_data_items_const()BOT = telebot.TeleBot(TOKEN)  # BOT = telebot.TeleBot(MyFileWorker.load_bot_token())OPERATOR_DATA = MyFileWorker.load_data_of_operator()temporary_values = {'list_of_photos_ids': [], "isGetMessageMethodPerforming": False, 'isGetUserDataPerforming': False,                    "isBGprocessPerforming": False, "isDoneProcessPerforming": False}class WithPhotosFromMessagesWorker:    def get_photo_from_message(self, message):        """Retrieves and returns photos from a message."""        if message.content_type == 'photo':            photo_id = message.photo[len(message.photo) - 1].file_id            name = photo_id + ".jpg"            photo_file = BOT.get_file(photo_id)            downloaded_file = BOT.download_file(photo_file.file_path)            DataWithBackupDumper.dump_image(downloaded_file, name)            return {"name": name, "media_group_id": str(message.media_group_id)}        elif message.content_type == 'document':            photo_id = message.document.file_id            name = photo_id + ".jpg"            photo_file = BOT.get_file(photo_id)            downloaded_file = BOT.download_file(photo_file.file_path)            DataWithBackupDumper.dump_image(downloaded_file, name)            return {"name": name, "media_group_id": str(message.media_group_id)}        else:            return {}class WithDataWorker:    """    Methods:        get_new_user(message)        change_user_dict(chat_id, user_dict)        delete_user(chat_id)        update_data_of_users(self)        process_new_user(message)        get_firstname(message, new_user_dict)        get_lastname(self, message, new_user_dict)        get_subdivision(message, new_user_dict)        get_email(message, new_user_dict)        get_phone_number(message, new_user_dict)        finish_process_new_user(message, new_user_dict)    """    def __init__(self):        self.data_of_users = MyFileWorker.load_data_of_users()  # Stores all personal data of users    def get_new_user(self, message, add_user_to_problems_f, user_get_f=None):        """            Entering the chain of obtaining user data.            (user_get_f - refers to get_new_problem method)        """        temporary_values[str(message.chat.id)]['isGetUserDataPerforming'] = True        temporary_values['isGetUserDataPerforming'] = True        self.process_new_user(message, add_user_to_problems_f, user_get_f)    def change_user_dict(self, chat_id, user_dict):        """Overwrites the changed data in the user's dictionary."""        while True:            self.data_of_users[chat_id] = user_dict            DataWithBackupDumper.dump_data_of_users(self.data_of_users)            self.update_data_of_users()            if chat_id in self.data_of_users:                break            time.sleep(0.1)    def delete_user(self, chat_id):        """Removes a user's dictionary from the database."""        print("hah")        while chat_id in self.data_of_users:            print("some")            self.data_of_users.pop(chat_id)            DataWithBackupDumper.dump_data_of_users(self.data_of_users)            self.update_data_of_users()    def update_data_of_users(self):        """Loads data from a json file into self.data_of_users"""        self.data_of_users = MyFileWorker.load_data_of_users()    def process_new_user(self, message, add_user_to_problems_f, user_get_f=None):        new_user_dict = {"deleted": False}        BOT.register_next_step_handler(BOT.send_message(str(message.chat.id), "Введите ваше имя: "), self.get_firstname,                                       new_user_dict, add_user_to_problems_f, user_get_f)        print("Ждём имя")    def get_firstname(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        if message.content_type != 'text':            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите, пожалуйста, имя в текстовом формате: "),                self.get_firstname, new_user_dict, add_user_to_problems_f, user_get_f)        else:            print('Имя:')            print(message.text)            new_user_dict[DATA_ITEMS[0]] = message.text            # time.sleep(1)            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите вашу фамилию: "),                self.get_lastname, new_user_dict, add_user_to_problems_f, user_get_f)    def get_lastname(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        if message.content_type != 'text':            print('введён не текст')            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите, пожалуйста, фамилию в текстовом формате: "),                self.get_lastname, new_user_dict, add_user_to_problems_f, user_get_f)        else:            print('Фамилия:')            print(message.text)            new_user_dict[DATA_ITEMS[1]] = message.text            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите ваше подразделение:"), self.get_subdivision,                new_user_dict, add_user_to_problems_f, user_get_f)    def get_subdivision(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        if message.content_type != 'text':            print('введён не текст')            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id),                                 "Введите, пожалуйста, подразделение в текстовом формате:"),                self.get_subdivision, new_user_dict, add_user_to_problems_f, user_get_f)        else:            print('Подразделение:')            print(message.text)            new_user_dict[DATA_ITEMS[2]] = message.text            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите ваш адрес электронной почты:"), self.get_email,                new_user_dict, add_user_to_problems_f, user_get_f)    def get_email(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        if message.content_type != 'text':            print('введён не текст')            BOT.register_next_step_handler(BOT.send_message(str(message.chat.id),                                                            "Введите, пожалуйста, адрес электронной почты "                                                            "в текстовом формате:"),                                           self.get_email, new_user_dict, add_user_to_problems_f, user_get_f)        elif '@' not in message.text or '.' not in message.text:            BOT.register_next_step_handler(BOT.send_message(str(message.chat.id),                                                            "Введите, пожалуйста, адрес электронной почты "                                                            "в корректном формате:"),                                           self.get_email, new_user_dict, add_user_to_problems_f, user_get_f)        else:            print('Почта:')            print(message.text)            new_user_dict[DATA_ITEMS[3]] = message.text            BOT.register_next_step_handler(                BOT.send_message(str(message.chat.id), "Введите ваш телефонный номер для контакта: "),                self.get_phone_number, new_user_dict, add_user_to_problems_f, user_get_f)    def get_phone_number(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        if message.content_type != 'text':            BOT.register_next_step_handler(BOT.send_message(str(message.chat.id),                                                            "Введите, пожалуйста, телефонный номер в "                                                            "текстовом формате: "),                                           self.get_phone_number, new_user_dict, add_user_to_problems_f, user_get_f)        else:            print('Номер:')            print(message.text)            new_user_dict[DATA_ITEMS[4]] = message.text            self.finish_process_new_user(message, new_user_dict, add_user_to_problems_f, user_get_f)    def finish_process_new_user(self, message, new_user_dict, add_user_to_problems_f, user_get_f=None):        print(f"User's personal data received ({str(message.chat.id)}):\n{str(new_user_dict)}")        logging.info(f"User's personal data received ({str(message.chat.id)}):\n{str(new_user_dict)}")        temporary_values[str(message.chat.id)]['isGetUserDataPerforming'] = False        temporary_values['isGetUserDataPerforming'] = False        self.change_user_dict(str(message.chat.id), new_user_dict)        add_user_to_problems_f(str(message.chat.id))        if user_get_f is not None:            user_get_f(message)class WithProblemsWorker:    """    Methods:        update_problems_of_users()        delete_user_problems(chat_id)        change_problem_dict(chat_id, new_problem_dict, date_key)        add_new_user(chat_id)        add_new_problem(chat_id, new_problem_dict)        get_problem_source_with_number(number)        mark_problem_completed(message, number)        get_new_problem(message)        process_new_problem(message)        start_get_photos(message, new_problem_dict)        finish_process_new_problem(message, new_problem_dict)        get_photos_list_with_mediagroupid(media_group_id)        get_last_appeal_key(message)    """    def __init__(self):        self.problems_of_users = MyFileWorker.load_problems_of_users()        self.next_reminder = NEXT_REMINDER        self.with_photos_from_messages_worker = WithPhotosFromMessagesWorker()    def update_problems_of_users(self):        """Loads problems from a json file into self.problems_of_users"""        self.problems_of_users = MyFileWorker.load_problems_of_users()    def delete_user_problems(self, chat_id):        """Removes a user's problems from the database."""        while chat_id in self.problems_of_users:            print('tryd')            self.problems_of_users.pop(chat_id)            DataWithBackupDumper.dump_problems_of_users(self.problems_of_users)            self.update_problems_of_users()    def change_problem_dict(self, chat_id, new_problem_dict, date_key):        """Overwrites the changed problems data in the problem dictionary."""        while True:            self.problems_of_users[chat_id][date_key] = new_problem_dict            DataWithBackupDumper.dump_problems_of_users(self.problems_of_users)            self.update_problems_of_users()            if date_key in self.problems_of_users[chat_id]:                break            time.sleep(0.1)    def add_new_user(self, chat_id):        """Adds new user to problems_of_users."""        while True:            self.problems_of_users[chat_id] = {}            DataWithBackupDumper.dump_problems_of_users(self.problems_of_users)            self.update_problems_of_users()            if chat_id in self.problems_of_users:                break            time.sleep(0.1)    def add_new_problem(self, chat_id, new_problem_dict):        """Adds a new problem dictionary to problems_of_users."""        while True:            date_key = datetime.today().strftime("%d.%m.%y %H:%M:%S")            self.problems_of_users[chat_id][date_key] = new_problem_dict            DataWithBackupDumper.dump_problems_of_users(self.problems_of_users)            self.update_problems_of_users()            if date_key in self.problems_of_users[chat_id]:                break            time.sleep(0.1)    def get_problem_source_with_number(self, number):        """Returns the path to the problem at a specific number"""        self.update_problems_of_users()        source_dict = None        for chat_id in self.problems_of_users:            for date_key in self.problems_of_users[chat_id]:                if number == self.problems_of_users[chat_id][date_key]['number']:                    source_dict = {"chat_id": chat_id, "date_key": date_key}        return source_dict    def mark_problem_completed(self, message, number):        """Marks as solved a problem with a number."""        source = self.get_problem_source_with_number(number)        if source is not None:            if not self.problems_of_users[source["chat_id"]][source["date_key"]]["issolved"]:                new_problem_dict = self.problems_of_users[source["chat_id"]][source["date_key"]].copy()                new_problem_dict["issolved"] = True                self.change_problem_dict(source["chat_id"], new_problem_dict, source["date_key"])                text = f"Заявка с номером {number} от {source['chat_id']} отмечена решённой"                BOT.send_message(str(message.chat.id), text)                print(text)                logging.info(text)            else:                BOT.send_message(str(message.chat.id),                                 "Заявка с номером " + str(number) + " уже была отмечена решённой.")        else:            BOT.send_message(str(message.chat.id), "Такого номера заявки не существует.")        temporary_values["isDoneProcessPerforming"] = False    def get_new_problem(self, message):        """Entering the chain of receiving problem data from the user."""        self.update_problems_of_users()        BOT.register_next_step_handler(            BOT.send_photo(str(message.chat.id), PhrasesGenerator.get_text_with_input_suggestion()[1],                           PhrasesGenerator.get_text_with_input_suggestion()[0]),            self.process_new_problem)    def process_new_problem(self, message):        """Processes the text of the problem (Possibly with photos) received from the user."""        temporary_values[str(message.chat.id)]["isGetMessageMethodPerforming"] = True        if str(message.chat.id) in self.problems_of_users:            print("Обрабатываем проблему, которую прислал пользователь")            # If a type to be processed is received.            if message.content_type == 'text' or message.content_type == 'photo' or message.content_type == 'document':                new_problem_dict = {'issolved': False, "next_reminder": int(time.time() + self.next_reminder),                                    "date": int(time.time())}                if message.content_type == 'text':                    mes_text = message.text                else:                    mes_text = message.caption                if mes_text is not None:                    new_problem_dict["text"] = mes_text                else:                    new_problem_dict["text"] = "Отсутствует"                new_problem_dict["number"] = MyFileWorker.load_counter_of_orders()                DataWithBackupDumper.dump_counter_of_orders(new_problem_dict["number"] + 1)                self.start_get_photos(message, new_problem_dict)            else:                print(                    f"User {str(message.chat.id)} sent a message of an unprocessed type ({str(message.content_type)}) as a request ")                logging.info(                    f"User {str(message.chat.id)} sent a message of an unprocessed type ({str(message.content_type)}) as a request ")        else:            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_text_about_deleted_data())        temporary_values[str(message.chat.id)]["isGetMessageMethodPerforming"] = False    def start_get_photos(self, message, new_problem_dict):        """Adds photos from the received message to the case, if any."""        if message.content_type == 'photo' or message.content_type == 'document':            photo_dict = self.with_photos_from_messages_worker.get_photo_from_message(message)            new_problem_dict['photos'] = [photo_dict]        else:            new_problem_dict["photos"] = []        new_problem_dict['howPointsToSendToOperator'] = 3        self.finish_process_new_problem(message, new_problem_dict)    def finish_process_new_problem(self, message, new_problem_dict):        self.add_new_problem(str(message.chat.id), new_problem_dict)        BOT.send_message(str(message.chat.id),                         PhrasesGenerator.get_final_text_of_appeal(new_problem_dict["number"]))        print(f"Problem added as number {new_problem_dict['number']} by user {message.chat.id}\n {new_problem_dict}")        logging.info(            f"Problem added as number {new_problem_dict['number']} by user {message.chat.id}\n {new_problem_dict}")    def get_photos_list_with_mediagroupid(self, media_group_id):        """Returns a list with a photo by media_group_id."""        self.update_problems_of_users()        source_dict = None        for chat_id in self.problems_of_users:            for date_key in self.problems_of_users[chat_id]:                if 'photos' in self.problems_of_users[chat_id][date_key]:                    for photo in self.problems_of_users[chat_id][date_key]['photos']:                        if photo['media_group_id'] == media_group_id:                            source_dict = {"chat_id": chat_id, "date_key": date_key}                            return source_dict        return source_dict    def get_last_appeal_key(self, message):        """Returns the key of the last problem added by the user."""        self.update_problems_of_users()        max_date = 0        result = None        for date_key in self.problems_of_users[str(message.chat.id)]:            if self.problems_of_users[str(message.chat.id)][date_key]['date'] >= max_date:                max_date = self.problems_of_users[str(message.chat.id)][date_key]['date']                result = date_key        return resultclass MessagesHandler:    """    Methods:        reply_to_text(message)        reply_to_photo(message)        reply_to_document(message)        reply_to_start_command(message)        set_initial_pers_temp_values(chat_id)    """    def __init__(self, with_data_worker, with_problems_worker):        operator_data_list = OPERATOR_DATA        self.operator_id = operator_data_list["chat_id"]        self.operator_mail = operator_data_list["email"]        self.operator_mail_password = operator_data_list["password"]        self.with_data_worker = with_data_worker        self.with_problems_worker = with_problems_worker        self.with_photos_from_messages_worker = WithPhotosFromMessagesWorker()    def reply_to_text(self, message):        """            This method will be called if the bot receives a 'text' type as a message.            Processes the content of the user's message.        """        self.set_initial_pers_temp_values(str(message.chat.id))        if temporary_values[str(message.chat.id)]['isGetUserDataPerforming'] or \                temporary_values[str(message.chat.id)]["isGetMessageMethodPerforming"] or \                temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"]:            return        while True:            if not temporary_values["isDoneProcessPerforming"]:                temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            time.sleep(0.1)        print(f" ' {message.text} ' by {message.from_user.first_name} {message.chat.id}")        self.with_problems_worker.update_problems_of_users()        # If operator details are not specified.        if self.operator_id == "":            print("Введите данные оператора в приложении")        # If a message is received from an operator.        elif str(message.chat.id) == self.operator_id:            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        else:            # If user data has already been received            if self.with_data_worker.data_of_users.get(                    str(message.chat.id)) is not None \                    and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:                self.with_data_worker.update_data_of_users()                BOT.send_message(str(message.chat.id),                                 PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                self.with_problems_worker.get_new_problem(message)            else:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        temporary_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_photo(self, message):        """            This method will be called if the bot receives a 'photo' type as a message.            Processes the content of the user's message.        """        self.set_initial_pers_temp_values(str(message.chat.id))        if temporary_values[str(message.chat.id)]['isGetUserDataPerforming']:            return        # If a method for processing a message or receiving a problem for this user is already running, then        # the process is queued        while True:            if temporary_values[str(message.chat.id)]["isGetMessageMethodPerforming"] == False and \                    temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] == False \                    and temporary_values["isDoneProcessPerforming"] == False:                temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            time.sleep(0.1)        print(f"Photo by {message.from_user.first_name} {message.chat.id}")        logging.info(f"Photo by {message.from_user.first_name} {message.chat.id}")        # If this photo belongs to a post with a group of photos that we have already replied to.        if str(message.media_group_id) in temporary_values['list_of_photos_ids']:            print("Отбрасываем фото, которое принадлежит к сообщению с группой фотографий, на которое мы уже ответили")            temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False            temporary_values[str(message.chat.id)]["last_message"] = time.time()            return        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        elif self.with_data_worker.data_of_users.get(                str(message.chat.id)) is not None \                and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:            if message.media_group_id is not None:  # If a group of photos was sent.                source_dict = self.with_problems_worker.get_photos_list_with_mediagroupid(str(message.media_group_id))                if source_dict is None:  # If no photos of this group have been added to the problems.                    temporary_values['list_of_photos_ids'].append(str(message.media_group_id))                    if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                        self.with_problems_worker.update_problems_of_users()                        BOT.send_message(str(message.chat.id),                                         PhrasesGenerator.get_hello_text_with_data(                                             str(message.chat.id)))                        self.with_problems_worker.get_new_problem(message)                else:  # Otherwise, there is already a problem with the photos of this media group and we add photos there.                    photo_dict = self.with_photos_from_messages_worker.get_photo_from_message(message)                    self.with_problems_worker.update_problems_of_users()                    dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                        source_dict['date_key']].copy()                    dict_with_new_photos["photos"].append(photo_dict)                    self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                  source_dict['date_key'])            else:  # Otherwise, this is a single photo.                if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                    self.with_problems_worker.update_problems_of_users()                    BOT.send_message(str(message.chat.id),                                     PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                    self.with_problems_worker.get_new_problem(message)        else:  # If user data has not yet been received.            temporary_values['list_of_photos_ids'].append(str(message.media_group_id))            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())            self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                self.with_problems_worker.get_new_problem)        temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        temporary_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_document(self, message):        """            This method will be called if the bot receives a "document" type as a message.            Processes the content of the user's message.        """        # If no initial values have been set yet.        self.set_initial_pers_temp_values(str(message.chat.id))        if temporary_values[str(message.chat.id)]['isGetUserDataPerforming']:            return        # If a method for processing a message or receiving a problem for this user is already running, then        # the process is queued.        while True:            if temporary_values[str(message.chat.id)]["isGetMessageMethodPerforming"] == False and \                    temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] == False \                    and temporary_values["isDoneProcessPerforming"] == False:                temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            print("Процесс попал в очередь:")            print(temporary_values)            time.sleep(0.1)        print(f"File by {message.from_user.first_name} {message.chat.id}")        logging.info(f"File by {message.from_user.first_name} {message.chat.id}")        # If this photo belongs to a post with a group of photos that we have already replied to.        if str(message.media_group_id) in temporary_values['list_of_photos_ids']:            print("Отбрасываем фото, которое принадлежит к сообщению с группой фотографий, на которое мы уже ответили")            temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False            temporary_values[str(message.chat.id)]["last_message"] = time.time()            return        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        # If user data has already been received.        elif self.with_data_worker.data_of_users.get(str(message.chat.id)) is not None \                and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:            if message.media_group_id is not None:  # If a group of photos was sent.                source_dict = self.with_problems_worker.get_photos_list_with_mediagroupid(str(message.media_group_id))                if source_dict is None:  # If no photos of this group have been added to problems yet.                    last_problem_key = self.with_problems_worker.get_last_appeal_key(message)                    # If the telegram split the photo and text with it into 2 messages.                    if last_problem_key is not None and (int(time.time()) - self.with_problems_worker.problems_of_users[                        str(message.chat.id)][last_problem_key]['date'] <= 5) \                            and (len(                        self.with_problems_worker.problems_of_users[str(message.chat.id)][last_problem_key][                            'photos']) == 0):                        photo_dict = self.with_photos_from_messages_worker.get_photo_from_message(message)                        self.with_problems_worker.update_problems_of_users()                        dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                            last_problem_key].copy()                        dict_with_new_photos["photos"].append(photo_dict)                        self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                      last_problem_key)                    else:  # Otherwise, this message is the first photo from the media group we are responding to.                        temporary_values['list_of_photos_ids'].append(str(message.media_group_id))                        if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                            BOT.send_message(str(message.chat.id),                                             PhrasesGenerator.get_hello_text_with_data(                                                 str(message.chat.id)))                            self.with_problems_worker.get_new_problem(message)                else:  # Otherwise, there is already a problem with the photos of this media group and we add photos there.                    photo_dict = self.with_photos_from_messages_worker.get_photo_from_message(message)                    self.with_data_worker.update_data_of_users()                    dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                        source_dict['date_key']].copy()                    dict_with_new_photos["photos"].append(photo_dict)                    self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                  source_dict['date_key'])            else:  # Otherwise, this is a single photo.                if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                    self.with_problems_worker.update_problems_of_users()                    BOT.send_message(str(message.chat.id),                                     PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                    self.with_problems_worker.get_new_problem(message)        else:  # If user data has not yet been received.            temporary_values['list_of_photos_ids'].append(str(message.media_group_id))            if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        temporary_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        temporary_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_start_command(self, message):        """            This method should be called when the user enters the 'start' command.            Processes the content of the user's message.        """        print(f"start/ command by {message.chat.id}")        logging.info(f"start/ command by {message.chat.id}")        self.with_problems_worker.update_problems_of_users()        self.set_initial_pers_temp_values(str(message.chat.id))        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        # If user data has not yet been received.        elif self.with_data_worker.data_of_users.get(str(message.chat.id)) is None \                or self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is None:            if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        else:  # Otherwise, user data is received.            if time.time() - temporary_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id),                                 PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                self.with_problems_worker.get_new_problem(message)        temporary_values[str(message.chat.id)]["last_message"] = time.time()    def set_initial_pers_temp_values(self, chat_id):        if not (chat_id in temporary_values):            temporary_values[chat_id] = {}            temporary_values[chat_id]['isGetUserDataPerforming'] = False            temporary_values[chat_id]["isAnswerMethodPerforming"] = False            temporary_values[chat_id]["isGetMessageMethodPerforming"] = False            temporary_values[chat_id]["last_message"] = 0class BackgroundProcessPerformer:    def __init__(self, with_data_worker, with_problems_worker):        self.with_data_worker = with_data_worker        self.with_problems_worker = with_problems_worker        self.operator_data_list = OPERATOR_DATA        self.operator_id = self.operator_data_list["chat_id"]        self.next_reminder = NEXT_REMINDER    def do_background_process(self):        """          The method runs constantly in the background.          It happens in it:              Sending notifications to the operator about outstanding tasks.              Sending new problems to the operator.              tracking changes in task status.        """        print("Запуск фонового процесса")        while True:            time.sleep(1)            if not temporary_values['isGetMessageMethodPerforming']:                self.with_problems_worker.update_problems_of_users()                self.with_data_worker.update_data_of_users()                # If operator details are not specified.                if self.operator_id == "":                    print("Введите данные оператора в приложении")                else:                    for chat_id in list(self.with_problems_worker.problems_of_users):                        if self.with_data_worker.data_of_users[chat_id]['deleted']:                            print(f"The operator deleted the user {chat_id} from the database")                            logging.info(f"The operator deleted the user {chat_id} from the database")                            self.with_data_worker.delete_user(chat_id)                            self.with_problems_worker.delete_user_problems(chat_id)                        elif (chat_id in temporary_values) == False or (                                temporary_values[chat_id]["isGetMessageMethodPerforming"] == False and                                temporary_values[chat_id]["isAnswerMethodPerforming"] == False):                            temporary_values["isBGprocessPerforming"] = True                            for date_key in self.with_problems_worker.problems_of_users[chat_id].copy():                                print(self.with_problems_worker.problems_of_users[chat_id][date_key][                                          "howPointsToSendToOperator"])                                # If it's time to send notification to operator about new problem.                                if self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == 0:                                    text = PhrasesGenerator.get_new_problem_text_for_operator(chat_id,                                                                                                               date_key)                                    ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                   photos=                                                                                   self.with_problems_worker.problems_of_users[                                                                                       chat_id][date_key]['photos'])                                    ToOperatorByEmailSender.send_to_operator(text,self.operator_data_list,                                                                                                     photos=                                                                                                     self.with_problems_worker.problems_of_users[                                                                                                         chat_id][                                                                                                         date_key][                                                                                                         'photos'])                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] = -1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the message has already been sent.                                elif self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == -1:                                    pass                                # Otherwise, the message must be sent later.                                else:                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] -= 1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the problem is marked as unresolved.                                if not self.with_problems_worker.problems_of_users[chat_id][date_key]["issolved"]:                                    # If it's time for a reminder.                                    if int(time.time()) > \                                            self.with_problems_worker.problems_of_users[chat_id][date_key][                                                "next_reminder"]:                                        print("Отправляем напоминание")                                        text = PhrasesGenerator.get_reminder_text(chat_id, date_key)                                        ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                       photos=                                                                                       self.with_problems_worker.problems_of_users[                                                                                           chat_id][date_key]['photos'])                                        ToOperatorByEmailSender.send_to_operator(text,                                                                                                         self.operator_data_list,                                                                                                         photos=                                                                                                         self.with_problems_worker.problems_of_users[                                                                                                             chat_id][                                                                                                             date_key][                                                                                                             'photos'])                                        new_problem_dict = self.with_problems_worker.problems_of_users[chat_id][                                            date_key].copy()                                        new_problem_dict["next_reminder"] = int(time.time()) + self.next_reminder                                        self.with_problems_worker.change_problem_dict(chat_id, new_problem_dict,                                                                                      date_key)                            temporary_values["isBGprocessPerforming"] = Falsedef main():    with_data_worker = WithDataWorker()    with_problems_worker = WithProblemsWorker()    messages_handler = MessagesHandler(with_data_worker, with_problems_worker)    background_process_performer = BackgroundProcessPerformer(with_data_worker, with_problems_worker)    # Catching the "/start" command.    @BOT.message_handler(commands=["start"])    def answer_to_start_command(message):        messages_handler.reply_to_start_command(message)    # Catching the "/done" command.    @BOT.message_handler(commands=["done"])    def answer_to_done_command(message):        text = message.text.split(' ')        if OPERATOR_DATA['chat_id'] == "":            print(" Введите данные оператора в приложении")        elif OPERATOR_DATA['chat_id'] == str(message.chat.id):            if len(text) == 2:                if text[1].isdigit():                    with_problems_worker.mark_problem_completed(message, int(text[1]))                else:                    BOT.send_message(str(message.chat.id),                                     "Неккоректная форма команды\nПопробуйте так (Без кавычек):\n/done номер_заявки")            else:                BOT.send_message(str(message.chat.id),                                 "Неккоректная форма команды\nПопробуйте так:\n/done номер_заявки")    # Catching messages of type "text".    @BOT.message_handler(content_types=["text"])    def answer_to_text(message):        messages_handler.reply_to_text(message)    # Catching messages of type "photo"    @BOT.message_handler(content_types=["photo"])    def answer_to_photo(message):        messages_handler.reply_to_photo(message)    # Catching messages of type "document"    @BOT.message_handler(content_types=["document"])    def answer_to_document(message):        messages_handler.reply_to_document(message)    background_process_performer.background_thread = threading.Thread(        target=background_process_performer.do_background_process)    background_process_performer.background_thread.start()    print("Bot launched")    BOT.infinity_polling(timeout=10, long_polling_timeout=5)if __name__ == "__main__":    main()