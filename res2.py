import telebotimport osimport timeimport threadingimport MyFileWorkerimport loggingimport tracebackimport PhrasesGeneratorimport ToOperatorByEmailSenderimport ToOperatorByTelegramSenderimport PhotosFromMessageGetterimport WithDataWorkerimport TemporaryValuesKeeperimport WithProblemsWorkerimport MessagesHandlerlogging.basicConfig(    format='%(asctime)s: %(message)s',    level=logging.INFO,    filename='sample.log')# TOKEN = "2067410069:AAFKW4DZBnfBe0TgjJj0XVZgtTpAv99GQ-o"# TOKEN = "2099803367:AAGUn8M-X9_ivu2a3i76irQOGt5ryKkQpEs" not for use# TOKEN = "2054566773:AAE2sa4UmBWR8L8IbdT3CgTZo9v1NIzgVGg"# test for hope# TOKEN = "2034775644:AAHxVkYH1L8F6WPcErp0e7iNT82TYxAlNdM"  # test for meTOKEN = "5004761639:AAF6eincMdb2JSgKtw7-aZJRyYwaEpgYAmg"NEXT_REMINDER = 720DATA_ITEMS = MyFileWorker.load_data_items_const()BOT = telebot.TeleBot(TOKEN)  # BOT = telebot.TeleBot(MyFileWorker.load_bot_token())OPERATOR_DATA = MyFileWorker.load_data_of_operator()class BackgroundProcessPerformer:    def __init__(self, with_data_worker, with_problems_worker, temporary_values_keeper):        self.with_data_worker = with_data_worker        self.with_problems_worker = with_problems_worker        self.operator_data_list = OPERATOR_DATA        self.operator_id = self.operator_data_list["chat_id"]        self.next_reminder = NEXT_REMINDER        self.temporary_values_keeper = temporary_values_keeper    def do_background_process(self):        """          The method runs constantly in the background.          It happens in it:              Sending notifications to the operator about outstanding tasks.              Sending new problems to the operator.              tracking changes in task status.        """        print("Запуск фонового процесса")        while True:            time.sleep(1)            if not self.temporary_values_keeper.temp_values['isGetMessageMethodPerforming']:                self.with_problems_worker.update_problems_of_users()                self.with_data_worker.update_data_of_users()                # If operator details are not specified.                if self.operator_id == "":                    print("Введите данные оператора в приложении")                else:                    for chat_id in list(self.with_problems_worker.problems_of_users):                        if self.with_data_worker.data_of_users[chat_id]['deleted']:                            print(f"The operator deleted the user {chat_id} from the database")                            logging.info(f"The operator deleted the user {chat_id} from the database")                            self.with_data_worker.delete_user(chat_id)                            self.with_problems_worker.delete_user_problems(chat_id)                        elif (chat_id in self.temporary_values_keeper.temp_values) == False or (                                self.temporary_values_keeper.temp_values[chat_id]["isGetMessageMethodPerforming"] == False and                                self.temporary_values_keeper.temp_values[chat_id]["isAnswerMethodPerforming"] == False):                            self.temporary_values_keeper.temp_values["isBGprocessPerforming"] = True                            for date_key in self.with_problems_worker.problems_of_users[chat_id].copy():                                print(self.with_problems_worker.problems_of_users[chat_id][date_key][                                          "howPointsToSendToOperator"])                                # If it's time to send notification to operator about new problem.                                if self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == 0:                                    text = PhrasesGenerator.get_new_problem_text_for_operator(chat_id,                                                                                              date_key)                                    ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                photos=                                                                                self.with_problems_worker.problems_of_users[                                                                                    chat_id][date_key]['photos'])                                    ToOperatorByEmailSender.send_to_operator(text, self.operator_data_list,                                                                             photos=                                                                             self.with_problems_worker.problems_of_users[                                                                                 chat_id][                                                                                 date_key][                                                                                 'photos'])                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] = -1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the message has already been sent.                                elif self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == -1:                                    pass                                # Otherwise, the message must be sent later.                                else:                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] -= 1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the problem is marked as unresolved.                                if not self.with_problems_worker.problems_of_users[chat_id][date_key]["issolved"]:                                    # If it's time for a reminder.                                    if int(time.time()) > \                                            self.with_problems_worker.problems_of_users[chat_id][date_key][                                                "next_reminder"]:                                        print("Отправляем напоминание")                                        text = PhrasesGenerator.get_reminder_text(chat_id, date_key)                                        ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                    photos=                                                                                    self.with_problems_worker.problems_of_users[                                                                                        chat_id][date_key]['photos'])                                        ToOperatorByEmailSender.send_to_operator(text,                                                                                 self.operator_data_list,                                                                                 photos=                                                                                 self.with_problems_worker.problems_of_users[                                                                                     chat_id][                                                                                     date_key][                                                                                     'photos'])                                        new_problem_dict = self.with_problems_worker.problems_of_users[chat_id][                                            date_key].copy()                                        new_problem_dict["next_reminder"] = int(time.time()) + self.next_reminder                                        self.with_problems_worker.change_problem_dict(chat_id, new_problem_dict,                                                                                      date_key)                            self.temporary_values_keeper.temp_values["isBGprocessPerforming"] = Falsedef main():    temporary_values_keeper = TemporaryValuesKeeper.TemporaryValuesKeeper()    with_data_worker = WithDataWorker.WithDataWorker(BOT, temporary_values_keeper)    with_problems_worker = WithProblemsWorker.WithProblemsWorker(BOT, temporary_values_keeper)    messages_handler = MessagesHandler.MessagesHandler(BOT, with_data_worker, with_problems_worker, temporary_values_keeper)    background_process_performer = BackgroundProcessPerformer(with_data_worker, with_problems_worker, temporary_values_keeper)    # Catching the "/start" command.    @BOT.message_handler(commands=["start"])    def answer_to_start_command(message):        messages_handler.reply_to_start_command(message)    # Catching the "/done" command.    @BOT.message_handler(commands=["done"])    def answer_to_done_command(message):        text = message.text.split(' ')        if OPERATOR_DATA['chat_id'] == "":            print(" Введите данные оператора в приложении")        elif OPERATOR_DATA['chat_id'] == str(message.chat.id):            if len(text) == 2:                if text[1].isdigit():                    with_problems_worker.mark_problem_completed(message, int(text[1]))                else:                    BOT.send_message(str(message.chat.id),                                     "Неккоректная форма команды\nПопробуйте так (Без кавычек):\n/done номер_заявки")            else:                BOT.send_message(str(message.chat.id),                                 "Неккоректная форма команды\nПопробуйте так:\n/done номер_заявки")    # Catching messages of type "text".    @BOT.message_handler(content_types=["text"])    def answer_to_text(message):        messages_handler.reply_to_text(message)    # Catching messages of type "photo"    @BOT.message_handler(content_types=["photo"])    def answer_to_photo(message):        messages_handler.reply_to_photo(message)    # Catching messages of type "document"    @BOT.message_handler(content_types=["document"])    def answer_to_document(message):        messages_handler.reply_to_document(message)    background_process_performer.background_thread = threading.Thread(        target=background_process_performer.do_background_process)    background_process_performer.background_thread.start()    print("Bot launched")    BOT.infinity_polling(timeout=10, long_polling_timeout=5)if __name__ == "__main__":    main()