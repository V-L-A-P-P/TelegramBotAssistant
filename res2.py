import telebotimport osimport timeimport threadingimport MyFileWorkerimport loggingimport tracebackimport PhrasesGeneratorimport ToOperatorByEmailSenderimport ToOperatorByTelegramSenderimport PhotosFromMessageGetterfrom datetime import datetimeimport WithDataWorkerimport TemporaryValuesKeeperimport WithProblemsWorkerlogging.basicConfig(    format='%(asctime)s: %(message)s',    level=logging.INFO,    filename='sample.log')# TOKEN = "2067410069:AAFKW4DZBnfBe0TgjJj0XVZgtTpAv99GQ-o"# TOKEN = "2099803367:AAGUn8M-X9_ivu2a3i76irQOGt5ryKkQpEs" not for use# TOKEN = "2054566773:AAE2sa4UmBWR8L8IbdT3CgTZo9v1NIzgVGg"# test for hope# TOKEN = "2034775644:AAHxVkYH1L8F6WPcErp0e7iNT82TYxAlNdM"  # test for meTOKEN = "5004761639:AAF6eincMdb2JSgKtw7-aZJRyYwaEpgYAmg"NEXT_REMINDER = 720DATA_ITEMS = MyFileWorker.load_data_items_const()BOT = telebot.TeleBot(TOKEN)  # BOT = telebot.TeleBot(MyFileWorker.load_bot_token())OPERATOR_DATA = MyFileWorker.load_data_of_operator()class MessagesHandler:    """    Methods:        reply_to_text(message)        reply_to_photo(message)        reply_to_document(message)        reply_to_start_command(message)    """    def __init__(self, with_data_worker, with_problems_worker, temporary_values_keeper):        operator_data_list = OPERATOR_DATA        self.operator_id = operator_data_list["chat_id"]        self.operator_mail = operator_data_list["email"]        self.operator_mail_password = operator_data_list["password"]        self.with_data_worker = with_data_worker        self.with_problems_worker = with_problems_worker        self.temporary_values_keeper = temporary_values_keeper    def reply_to_text(self, message):        """            This method will be called if the bot receives a 'text' type as a message.            Processes the content of the user's message.        """        self.temporary_values_keeper.add_id(str(message.chat.id))        if self.temporary_values_keeper.temp_values[str(message.chat.id)]['isGetUserDataPerforming'] or \                self.temporary_values_keeper.temp_values[str(message.chat.id)]["isGetMessageMethodPerforming"] or \                self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"]:            return        while True:            if not self.temporary_values_keeper.temp_values["isDoneProcessPerforming"]:                self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            time.sleep(0.1)        print(f" ' {message.text} ' by {message.from_user.first_name} {message.chat.id}")        self.with_problems_worker.update_problems_of_users()        # If operator details are not specified.        if self.operator_id == "":            print("Введите данные оператора в приложении")        # If a message is received from an operator.        elif str(message.chat.id) == self.operator_id:            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        else:            # If user data has already been received            if self.with_data_worker.data_of_users.get(                    str(message.chat.id)) is not None \                    and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:                self.with_data_worker.update_data_of_users()                BOT.send_message(str(message.chat.id),                                 PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                self.with_problems_worker.get_new_problem(message)            else:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_photo(self, message):        """            This method will be called if the bot receives a 'photo' type as a message.            Processes the content of the user's message.        """        self.temporary_values_keeper.add_id(str(message.chat.id))        if self.temporary_values_keeper.temp_values[str(message.chat.id)]['isGetUserDataPerforming']:            return        # If a method for processing a message or receiving a problem for this user is already running, then        # the process is queued        while True:            if self.temporary_values_keeper.temp_values[str(message.chat.id)]["isGetMessageMethodPerforming"] == False and \                    self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] == False \                    and self.temporary_values_keeper.temp_values["isDoneProcessPerforming"] == False:                self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            time.sleep(0.1)        print(f"Photo by {message.from_user.first_name} {message.chat.id}")        logging.info(f"Photo by {message.from_user.first_name} {message.chat.id}")        # If this photo belongs to a post with a group of photos that we have already replied to.        if str(message.media_group_id) in self.temporary_values_keeper.temp_values['list_of_photos_ids']:            print("Отбрасываем фото, которое принадлежит к сообщению с группой фотографий, на которое мы уже ответили")            self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False            self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()            return        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        elif self.with_data_worker.data_of_users.get(                str(message.chat.id)) is not None \                and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:            if message.media_group_id is not None:  # If a group of photos was sent.                source_dict = self.with_problems_worker.get_photos_list_with_mediagroupid(str(message.media_group_id))                if source_dict is None:  # If no photos of this group have been added to the problems.                    self.temporary_values_keeper.temp_values['list_of_photos_ids'].append(str(message.media_group_id))                    if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                        self.with_problems_worker.update_problems_of_users()                        BOT.send_message(str(message.chat.id),                                         PhrasesGenerator.get_hello_text_with_data(                                             str(message.chat.id)))                        self.with_problems_worker.get_new_problem(message)                else:  # Otherwise, there is already a problem with the photos of this media group and we add photos there.                    photo_dict = PhotosFromMessageGetter.get_photo_from_message(BOT, message)                    self.with_problems_worker.update_problems_of_users()                    dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                        source_dict['date_key']].copy()                    dict_with_new_photos["photos"].append(photo_dict)                    self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                  source_dict['date_key'])            else:  # Otherwise, this is a single photo.                if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                    self.with_problems_worker.update_problems_of_users()                    BOT.send_message(str(message.chat.id),                                     PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                    self.with_problems_worker.get_new_problem(message)        else:  # If user data has not yet been received.            self.temporary_values_keeper.temp_values['list_of_photos_ids'].append(str(message.media_group_id))            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())            self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                               self.with_problems_worker.get_new_problem)        self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_document(self, message):        """            This method will be called if the bot receives a "document" type as a message.            Processes the content of the user's message.        """        # If no initial values have been set yet.        self.temporary_values_keeper.add_id(str(message.chat.id))        if self.temporary_values_keeper.temp_values[str(message.chat.id)]['isGetUserDataPerforming']:            return        # If a method for processing a message or receiving a problem for this user is already running, then        # the process is queued.        while True:            if self.temporary_values_keeper.temp_values[str(message.chat.id)]["isGetMessageMethodPerforming"] == False and \                    self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] == False \                    and self.temporary_values_keeper.temp_values["isDoneProcessPerforming"] == False:                self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = True                break            print("Процесс попал в очередь:")            print(self.temporary_values_keeper.temp_values)            time.sleep(0.1)        print(f"File by {message.from_user.first_name} {message.chat.id}")        logging.info(f"File by {message.from_user.first_name} {message.chat.id}")        # If this photo belongs to a post with a group of photos that we have already replied to.        if str(message.media_group_id) in self.temporary_values_keeper.temp_values['list_of_photos_ids']:            print("Отбрасываем фото, которое принадлежит к сообщению с группой фотографий, на которое мы уже ответили")            self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False            self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()            return        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        # If user data has already been received.        elif self.with_data_worker.data_of_users.get(str(message.chat.id)) is not None \                and self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is not None:            if message.media_group_id is not None:  # If a group of photos was sent.                source_dict = self.with_problems_worker.get_photos_list_with_mediagroupid(str(message.media_group_id))                if source_dict is None:  # If no photos of this group have been added to problems yet.                    last_problem_key = self.with_problems_worker.get_last_appeal_key(message)                    # If the telegram split the photo and text with it into 2 messages.                    if last_problem_key is not None and (int(time.time()) - self.with_problems_worker.problems_of_users[                        str(message.chat.id)][last_problem_key]['date'] <= 5) \                            and (len(                        self.with_problems_worker.problems_of_users[str(message.chat.id)][last_problem_key][                            'photos']) == 0):                        photo_dict = PhotosFromMessageGetter.get_photo_from_message(BOT, message)                        self.with_problems_worker.update_problems_of_users()                        dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                            last_problem_key].copy()                        dict_with_new_photos["photos"].append(photo_dict)                        self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                      last_problem_key)                    else:  # Otherwise, this message is the first photo from the media group we are responding to.                        self.temporary_values_keeper.temp_values['list_of_photos_ids'].append(str(message.media_group_id))                        if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                            BOT.send_message(str(message.chat.id),                                             PhrasesGenerator.get_hello_text_with_data(                                                 str(message.chat.id)))                            self.with_problems_worker.get_new_problem(message)                else:  # Otherwise, there is already a problem with the photos of this media group and we add photos there.                    photo_dict = PhotosFromMessageGetter.get_photo_from_message(BOT, message)                    self.with_data_worker.update_data_of_users()                    dict_with_new_photos = self.with_problems_worker.problems_of_users[str(message.chat.id)][                        source_dict['date_key']].copy()                    dict_with_new_photos["photos"].append(photo_dict)                    self.with_problems_worker.change_problem_dict(str(message.chat.id), dict_with_new_photos,                                                                  source_dict['date_key'])            else:  # Otherwise, this is a single photo.                if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                    self.with_problems_worker.update_problems_of_users()                    BOT.send_message(str(message.chat.id),                                     PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                    self.with_problems_worker.get_new_problem(message)        else:  # If user data has not yet been received.            self.temporary_values_keeper.temp_values['list_of_photos_ids'].append(str(message.media_group_id))            if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        self.temporary_values_keeper.temp_values[str(message.chat.id)]["isAnswerMethodPerforming"] = False        self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()    def reply_to_start_command(self, message):        """            This method should be called when the user enters the 'start' command.            Processes the content of the user's message.        """        print(f"start/ command by {message.chat.id}")        logging.info(f"start/ command by {message.chat.id}")        self.with_problems_worker.update_problems_of_users()        self.temporary_values_keeper.add_id(str(message.chat.id))        if self.operator_id == "":  # If operator details are not specified.            print("Введите данные оператора в приложении")        elif str(message.chat.id) == self.operator_id:  # If a message is received from an operator.            BOT.send_message(str(message.chat.id), PhrasesGenerator.get_info_text_for_operator())        # If user data has not yet been received.        elif self.with_data_worker.data_of_users.get(str(message.chat.id)) is None \                or self.with_data_worker.data_of_users.get(str(message.chat.id)).get("phonenumber") is None:            if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id), PhrasesGenerator.get_hello_text_without_data())                self.with_data_worker.get_new_user(message, self.with_problems_worker.add_new_user,                                                   self.with_problems_worker.get_new_problem)        else:  # Otherwise, user data is received.            if time.time() - self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] > 1:                BOT.send_message(str(message.chat.id),                                 PhrasesGenerator.get_hello_text_with_data(str(message.chat.id)))                self.with_problems_worker.get_new_problem(message)        self.temporary_values_keeper.temp_values[str(message.chat.id)]["last_message"] = time.time()class BackgroundProcessPerformer:    def __init__(self, with_data_worker, with_problems_worker, temporary_values_keeper):        self.with_data_worker = with_data_worker        self.with_problems_worker = with_problems_worker        self.operator_data_list = OPERATOR_DATA        self.operator_id = self.operator_data_list["chat_id"]        self.next_reminder = NEXT_REMINDER        self.temporary_values_keeper = temporary_values_keeper    def do_background_process(self):        """          The method runs constantly in the background.          It happens in it:              Sending notifications to the operator about outstanding tasks.              Sending new problems to the operator.              tracking changes in task status.        """        print("Запуск фонового процесса")        while True:            time.sleep(1)            if not self.temporary_values_keeper.temp_values['isGetMessageMethodPerforming']:                self.with_problems_worker.update_problems_of_users()                self.with_data_worker.update_data_of_users()                # If operator details are not specified.                if self.operator_id == "":                    print("Введите данные оператора в приложении")                else:                    for chat_id in list(self.with_problems_worker.problems_of_users):                        if self.with_data_worker.data_of_users[chat_id]['deleted']:                            print(f"The operator deleted the user {chat_id} from the database")                            logging.info(f"The operator deleted the user {chat_id} from the database")                            self.with_data_worker.delete_user(chat_id)                            self.with_problems_worker.delete_user_problems(chat_id)                        elif (chat_id in self.temporary_values_keeper.temp_values) == False or (                                self.temporary_values_keeper.temp_values[chat_id]["isGetMessageMethodPerforming"] == False and                                self.temporary_values_keeper.temp_values[chat_id]["isAnswerMethodPerforming"] == False):                            self.temporary_values_keeper.temp_values["isBGprocessPerforming"] = True                            for date_key in self.with_problems_worker.problems_of_users[chat_id].copy():                                print(self.with_problems_worker.problems_of_users[chat_id][date_key][                                          "howPointsToSendToOperator"])                                # If it's time to send notification to operator about new problem.                                if self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == 0:                                    text = PhrasesGenerator.get_new_problem_text_for_operator(chat_id,                                                                                              date_key)                                    ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                photos=                                                                                self.with_problems_worker.problems_of_users[                                                                                    chat_id][date_key]['photos'])                                    ToOperatorByEmailSender.send_to_operator(text, self.operator_data_list,                                                                             photos=                                                                             self.with_problems_worker.problems_of_users[                                                                                 chat_id][                                                                                 date_key][                                                                                 'photos'])                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] = -1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the message has already been sent.                                elif self.with_problems_worker.problems_of_users[chat_id][date_key][                                    'howPointsToSendToOperator'] == -1:                                    pass                                # Otherwise, the message must be sent later.                                else:                                    new_problems_dict = self.with_problems_worker.problems_of_users[chat_id][                                        date_key].copy()                                    new_problems_dict['howPointsToSendToOperator'] -= 1                                    self.with_problems_worker.change_problem_dict(chat_id, new_problems_dict, date_key)                                # If the problem is marked as unresolved.                                if not self.with_problems_worker.problems_of_users[chat_id][date_key]["issolved"]:                                    # If it's time for a reminder.                                    if int(time.time()) > \                                            self.with_problems_worker.problems_of_users[chat_id][date_key][                                                "next_reminder"]:                                        print("Отправляем напоминание")                                        text = PhrasesGenerator.get_reminder_text(chat_id, date_key)                                        ToOperatorByTelegramSender.send_to_operator(BOT, text, self.operator_data_list,                                                                                    photos=                                                                                    self.with_problems_worker.problems_of_users[                                                                                        chat_id][date_key]['photos'])                                        ToOperatorByEmailSender.send_to_operator(text,                                                                                 self.operator_data_list,                                                                                 photos=                                                                                 self.with_problems_worker.problems_of_users[                                                                                     chat_id][                                                                                     date_key][                                                                                     'photos'])                                        new_problem_dict = self.with_problems_worker.problems_of_users[chat_id][                                            date_key].copy()                                        new_problem_dict["next_reminder"] = int(time.time()) + self.next_reminder                                        self.with_problems_worker.change_problem_dict(chat_id, new_problem_dict,                                                                                      date_key)                            self.temporary_values_keeper.temp_values["isBGprocessPerforming"] = Falsedef main():    temporary_values_keeper = TemporaryValuesKeeper.TemporaryValuesKeeper()    with_data_worker = WithDataWorker.WithDataWorker(BOT, temporary_values_keeper)    with_problems_worker = WithProblemsWorker.WithProblemsWorker(BOT, temporary_values_keeper)    messages_handler = MessagesHandler(with_data_worker, with_problems_worker, temporary_values_keeper)    background_process_performer = BackgroundProcessPerformer(with_data_worker, with_problems_worker, temporary_values_keeper)    # Catching the "/start" command.    @BOT.message_handler(commands=["start"])    def answer_to_start_command(message):        messages_handler.reply_to_start_command(message)    # Catching the "/done" command.    @BOT.message_handler(commands=["done"])    def answer_to_done_command(message):        text = message.text.split(' ')        if OPERATOR_DATA['chat_id'] == "":            print(" Введите данные оператора в приложении")        elif OPERATOR_DATA['chat_id'] == str(message.chat.id):            if len(text) == 2:                if text[1].isdigit():                    with_problems_worker.mark_problem_completed(message, int(text[1]))                else:                    BOT.send_message(str(message.chat.id),                                     "Неккоректная форма команды\nПопробуйте так (Без кавычек):\n/done номер_заявки")            else:                BOT.send_message(str(message.chat.id),                                 "Неккоректная форма команды\nПопробуйте так:\n/done номер_заявки")    # Catching messages of type "text".    @BOT.message_handler(content_types=["text"])    def answer_to_text(message):        messages_handler.reply_to_text(message)    # Catching messages of type "photo"    @BOT.message_handler(content_types=["photo"])    def answer_to_photo(message):        messages_handler.reply_to_photo(message)    # Catching messages of type "document"    @BOT.message_handler(content_types=["document"])    def answer_to_document(message):        messages_handler.reply_to_document(message)    background_process_performer.background_thread = threading.Thread(        target=background_process_performer.do_background_process)    background_process_performer.background_thread.start()    print("Bot launched")    BOT.infinity_polling(timeout=10, long_polling_timeout=5)if __name__ == "__main__":    main()